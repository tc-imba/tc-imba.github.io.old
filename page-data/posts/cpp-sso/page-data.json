{"componentChunkName":"component---src-templates-post-post-jsx","path":"/posts/cpp-sso","result":{"data":{"markdownRemark":{"html":"<h2>Implementation of <code>std::string</code></h2>\n<h3><code>g++</code></h3>\n<p>In <code>g++</code> (libstdc++) implementation, Assuming a 64-bit OS, the class structure (with the size of each attribute) can be simplified as:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-keyword\">template</span>&#x3C;<span class=\"hljs-keyword\">typename</span> value_type>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">basic_string</span> {</span>\n    <span class=\"hljs-keyword\">enum</span> { __min_cap = <span class=\"hljs-number\">15</span> / <span class=\"hljs-keyword\">sizeof</span>(value_type) };\n\n    pointer   __data_;                     <span class=\"hljs-comment\">//  8 bytes</span>\n    size_type __size_;                     <span class=\"hljs-comment\">//  8 bytes</span>\n\n    <span class=\"hljs-keyword\">union</span> {\n        value_type __data_[__min_cap + <span class=\"hljs-number\">1</span>]; <span class=\"hljs-comment\">// 16 bytes</span>\n        size_type  __cap_;                 <span class=\"hljs-comment\">//  8 bytes</span>\n    } __u_;                                <span class=\"hljs-comment\">// 16 bytes</span>\n};                                         <span class=\"hljs-comment\">// 32 bytes</span></code></pre>\n<p>The capacity (<code>size_type</code>, 8 bytes) is combined with a char array in a union if the string length is less than local capacity.</p>\n<p>The template argument <code>value_type</code> is define to support both <code>char</code> and <code>wchar_t</code>.</p>\n<ul>\n<li><code>basic_string&#x3C;char></code> has a local capacity of 15.</li>\n<li><code>basic_string&#x3C;wchar_t></code> has a local capacity of 7.</li>\n<li>we need one more char to store <code>\\0</code>.</li>\n</ul>\n<br />\n<p>Both of them have a total size of 32 bytes. The size of the char array is 16 bytes, because in <code>g++</code>, a minimum block allocated by dynamic memory allocation (malloc/new) is 16 bytes (so less than 16 bytes is not a good optimization).</p>\n<p>You may notice that there exists an overhead of 8 bytes in the union. This is ignorable if you do not need to store huge amounts of small strings in memory.</p>\n<h3><code>llvm/clang</code></h3>\n<p>In <code>llvm/clang</code> (libc++) implementation, the overhead can be cancelled by a smarter design: using the entire structure to store the small string.</p>\n<p>We define two modes for each string: long string mode and short string mode, each in a separate struct, and then combine them together with a union.</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-keyword\">template</span>&#x3C;<span class=\"hljs-keyword\">typename</span> value_type>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">basic_string</span> {</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> __<span class=\"hljs-title\">long</span> {</span>\n        size_type __cap_;               <span class=\"hljs-comment\">// 8      bytes</span>\n        size_type __size_;              <span class=\"hljs-comment\">// 8      bytes</span>\n        pointer   __data_;              <span class=\"hljs-comment\">// 8      bytes</span>\n    };\n\n    <span class=\"hljs-keyword\">enum</span> {__min_cap = (<span class=\"hljs-keyword\">sizeof</span>(__long) - <span class=\"hljs-number\">1</span>) / <span class=\"hljs-keyword\">sizeof</span>(value_type) > <span class=\"hljs-number\">2</span> ?\n                      (<span class=\"hljs-keyword\">sizeof</span>(__long) - <span class=\"hljs-number\">1</span>) / <span class=\"hljs-keyword\">sizeof</span>(value_type) : <span class=\"hljs-number\">2</span>};\n\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> __<span class=\"hljs-title\">short</span> {</span>\n        <span class=\"hljs-keyword\">union</span> {\n            <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">char</span> __size_;      <span class=\"hljs-comment\">// 1      byte</span>\n            value_type __lx;            <span class=\"hljs-comment\">// 1 (2)  bytes for char(wchar_t)</span>\n        };                              <span class=\"hljs-comment\">// 1 (2)  bytes for char(wchar_t)</span>\n        value_type __data_[__min_cap];  <span class=\"hljs-comment\">// 23(22) bytes for char(wchar_t)</span>\n    };                                  <span class=\"hljs-comment\">// 24     bytes</span>\n\n    <span class=\"hljs-keyword\">union</span> {\n        __long  __l;                    <span class=\"hljs-comment\">// 24     bytes</span>\n        __short __s;                    <span class=\"hljs-comment\">// 24     bytes</span>\n    } __r_;                             <span class=\"hljs-comment\">// 24     bytes</span>\n}</code></pre>\n<p>In short string mode, the first byte of the string stores the size (which is less than 24). The rest bytes store the string locally. The variable <code>__lx</code> is used for alignment with <code>wchar_t</code>.</p>\n<p>In order to distinguish a long string from a short one, the first byte of a long string (also the first byte of its capacity) is set to a mask 0x80 (which is larger than the maximum length of short string). This mask actually half the maximum capacity of the long string, but 0x 7fff ffff ffff ffff is huge enough comparing to achievable memory size.</p>\n<p>This design eliminates the size of a string to 24 bytes, and provides a longer local string (15 -> 22 for <code>char</code>, or 7 -> 10 for <code>wchar_t</code>).</p>","timeToRead":2,"frontmatter":{"title":"C++ Small String Optimization","date":"2020-10-04T00:00:00.000Z","tags":["cpp"],"path":"posts/cpp-sso","excerpt":"In this post, SSO (small string optimization) in C++ is studied and some more efforts for small static strings are made.","links":null,"cover":null},"fileAbsolutePath":"/home/runner/work/tc-imba.github.io/tc-imba.github.io/content/posts/2020-10-04-cpp-sso/index.md","fields":{"parsed":{"commit":1604431885}}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/tc-imba.github.io/tc-imba.github.io/content/posts/2020-10-04-cpp-sso/index.md","postPath":"posts/cpp-sso","translations":[{"hreflang":"en","path":"/posts/cpp-sso"}]}},"staticQueryHashes":["4097791827"]}